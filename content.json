{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://liusongfneg.github.io","root":"/"},"pages":[],"posts":[{"title":"vue的双向绑定响应式原理","slug":"MVVM","date":"2021-04-20T02:02:28.000Z","updated":"2021-04-20T06:49:50.295Z","comments":true,"path":"2021/04/20/MVVM/","link":"","permalink":"https://liusongfneg.github.io/2021/04/20/MVVM/","excerpt":"1. definePropertyObject.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。不支持IE8及一下版本 备注：应当直接在 Object 构造器对象上调用此方法，而不是在任意一个 Object 类型的实例上调用。 语法： Object.defineProperty(obj, prop, descriptor)descriptor : 要定义或修改的属性描述符。 1234567891011121314// vue通过对象属性的setter和getter方法来监听数据的变化// get订阅，set发布let obj = &#123;&#125;Object.defineProperty(obj,&#x27;name&#x27; ,&#123; get: function () &#123; // 当属性被访问是，此方法被调用，也就是拦截到了数据 console.log(&quot;get方法被调用&quot;); &#125; set: function (newValue) &#123; // 当属性值被修改时，会调用此函数, console.log(&quot;set方法被调用&quot;); &#125; &#125;&#125;) 实列： 12&lt;input type=&quot;text&quot; class=&quot;inp-text&quot;&gt;&lt;p class=&quot;text-box&quot;&gt;&lt;/p&gt; 123456789101112131415161718192021let obj = &#123;&#125; Object.defineProperty(obj,&#x27;name&#x27; ,&#123; get: function () &#123; // 当属性被访问是，此方法被调用，也就是拦截到了数据 console.log(&quot;get方法被调用&quot;); &#125; set: function (newValue) &#123; // 当属性值被修改时，会调用此函数, console.log(&quot;set方法被调用&quot;); document.querySelector(&#x27;.text-box&#x27;).innerHTML = newValue; document.querySelector(&#x27;.inp-text&#x27;).value = newValue; &#125; &#125; &#125;) // addEventListener: 给DOM添加交互事件 // 获取对象属性值触发get、设置(修改)对象属性值触发set 从这里可以看出 数对象模型读取和修改都可以驱动view层的数据变化 document.querySelector(&#x27;.inp-text&#x27;).addEventListener(&#x27;keyup&#x27;, function (e) &#123; console.log(&#x27;obj.name:&#x27;, obj.name) // 访问name属性 obj.name = e.target.value; // 设置name属性的值 &#125;, false);","text":"1. definePropertyObject.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。不支持IE8及一下版本 备注：应当直接在 Object 构造器对象上调用此方法，而不是在任意一个 Object 类型的实例上调用。 语法： Object.defineProperty(obj, prop, descriptor)descriptor : 要定义或修改的属性描述符。 1234567891011121314// vue通过对象属性的setter和getter方法来监听数据的变化// get订阅，set发布let obj = &#123;&#125;Object.defineProperty(obj,&#x27;name&#x27; ,&#123; get: function () &#123; // 当属性被访问是，此方法被调用，也就是拦截到了数据 console.log(&quot;get方法被调用&quot;); &#125; set: function (newValue) &#123; // 当属性值被修改时，会调用此函数, console.log(&quot;set方法被调用&quot;); &#125; &#125;&#125;) 实列： 12&lt;input type=&quot;text&quot; class=&quot;inp-text&quot;&gt;&lt;p class=&quot;text-box&quot;&gt;&lt;/p&gt; 123456789101112131415161718192021let obj = &#123;&#125; Object.defineProperty(obj,&#x27;name&#x27; ,&#123; get: function () &#123; // 当属性被访问是，此方法被调用，也就是拦截到了数据 console.log(&quot;get方法被调用&quot;); &#125; set: function (newValue) &#123; // 当属性值被修改时，会调用此函数, console.log(&quot;set方法被调用&quot;); document.querySelector(&#x27;.text-box&#x27;).innerHTML = newValue; document.querySelector(&#x27;.inp-text&#x27;).value = newValue; &#125; &#125; &#125;) // addEventListener: 给DOM添加交互事件 // 获取对象属性值触发get、设置(修改)对象属性值触发set 从这里可以看出 数对象模型读取和修改都可以驱动view层的数据变化 document.querySelector(&#x27;.inp-text&#x27;).addEventListener(&#x27;keyup&#x27;, function (e) &#123; console.log(&#x27;obj.name:&#x27;, obj.name) // 访问name属性 obj.name = e.target.value; // 设置name属性的值 &#125;, false); _实际效果_： 2. 虚拟DOM-createDocumentFragmentcreatedocumentfragment()方法创建了一虚拟的节点对象，节点对象包含所有属性和方法。 1234&lt;div id=&quot;container&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;value&quot;/&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243var container = document.getElementById(&#x27;container&#x27;);var data = &#123; //这里我们把vue实例中的data提取出来，更加直观 msg: &#x27;Hello world!&#x27;, inpText: &#x27;Input value&#x27;,&#125;// 创建虚拟domvar fragment = virtualDom(container, data);container.appendChild(fragment);function virtualDom(dom,data)&#123; let frag = document.createDocumentFragment() let child; let i = 0; while (i &lt; dom.childNodes.length - 1) &#123; child = dom.childNodes[i] compile(child, data); frag.appendChild(child); &#125; return frag;&#125;function compile(node, data)&#123; let reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/g if (node.nodeType === 1) &#123; let attr = node.attributes; for (let i = 0, len = attr.length; i &lt; len; i++) &#123; if (attr[i].nodeName === &#x27;v-model&#x27;) &#123; let name = attr[i].nodeValue; node.value = data[name]; &#125; &#125; // hasChildNodes方法返回一个布尔值,表明当前节点是否包含有子节点. if (node.hasChildNodes()) &#123; node.childNodes.forEach((item) =&gt; &#123; compile(item, data); // 递归 &#125;); &#125; &#125; else if (node.nodeType === 3) &#123; if (reg.test(node.nodeValue)) &#123; let name = RegExp.$1; // 取&#123;&#123;&#125;&#125;中的值 name = name.trim(); // 去除两边的空格 node.nodeValue = data[name]; // 复制 &#125; &#125;&#125; 3. 发布订阅者模式简单来说就是：注册观察者，发布者通过notify通知，观察者通过update更新数据 123456789101112131415161718192021222324252627function Dep() &#123; this.subs = []&#125;Dep.prototype.add = function(sub)&#123; this.subs.push(sub)&#125;Dep.prototype.notify = function () &#123; this.subs.forEach(sub =&gt; &#123; sub.update() &#125;);&#125;function Watcher(fn) &#123; // watcher是一个类 this.fn = fn&#125;Watcher.prototype.update = function()&#123; this.fn()&#125;let watcher = new Watcher( function ()&#123; console.log(1) &#125;)let dep = new Dep()dep.add(watcher)// 注册订阅者dep.add(watcher)dep.add(watcher)dep.notify() // 发布 prototype: 对象的原型链 推荐文章 效果： 4. 实现双向绑定好了，现在我们就结合上面的知识来实现双向绑定了 12345678&lt;div id=&quot;container&quot;&gt; &#123;&#123; msg &#125;&#125;&lt;br&gt; &lt;input class=&quot;inp-text&quot; type=&quot;text&quot; v-model=&quot;inpText&quot;&gt; &lt;div class=&quot;text-box&quot;&gt; &lt;p class=&quot;show-text&quot;&gt;&#123;&#123; inpText &#125;&#125;&lt;/p&gt; &#123;&#123;text&#125;&#125; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125function Vue(options) &#123; this.data = options.data let id = options.el // 实现set和get observe(this.data, this) let container = document.getElementById(id); // 获取DOM let fragment = virtualDom(container, this); // 创建虚拟DOM console.log(&#x27;fragment: &#x27;, fragment) container.appendChild(fragment); // 完成&#125;// observefunction observe(data, vm) &#123; Object.keys(data).forEach(key =&gt; &#123; defineReact(vm, key, data[key]) &#125;)&#125;// defineReactfunction defineReact(vm, key, value) &#123; let publisher = new Publisher(); // 实例化发者 Object.defineProperty(vm, key, &#123; set: function (newValue) &#123; value = newValue publisher.notify() &#125;, get: function () &#123; if (Publisher.global) &#123; //这里为什么来添加判断条件，主要是让publisher.add只执行一次，初始化虚拟dom编译的时候来执行 publisher.add(Publisher.global); // 添加订阅者 &#125; return value; &#125; &#125;)&#125;// 创建虚拟DOM的方法function virtualDom(dom, vm) &#123; let frag = document.createDocumentFragment() let child; let i = 0; while (i &lt; dom.childNodes.length - 1) &#123; child = dom.childNodes[i] compile(child, vm); frag.appendChild(child); &#125; return frag&#125;function compile(node, vm) &#123; let reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/g; if (node.nodeType === 1) &#123; // 标签 let attr = node.attributes; for (let i = 0, len = attr.length; i &lt; len; i++) &#123; // if (attr[i].nodeName === &#x27;v-model&#x27;) &#123; let name = attr[i].nodeValue; node.value = vm[name]; // ------------------------添加监听事件 node.addEventListener(&#x27;keyup&#x27;, function (e) &#123; vm[name] = e.target.value; &#125;, false); // ----------------------------------- new Watcher(node, vm, name); &#125; &#125; if (node.hasChildNodes()) &#123; node.childNodes.forEach((item) =&gt; &#123; compile(item, vm); // 递归 &#125;); &#125; &#125; if (node.nodeType === 3) &#123; // 文本节点 if (reg.test(node.nodeValue)) &#123; let name = RegExp.$1; name = name.trim(); node.nodeValue = vm[name]; new Watcher(node, vm, name); &#125; &#125;&#125;function Publisher() &#123; this.subs = []&#125;// 发布Publisher.prototype.add = function (sub) &#123; this.subs.push(sub)&#125;Publisher.prototype.notify = function () &#123; this.subs.forEach(function (sub) &#123; sub.update() &#125;)&#125;// 订阅function Watcher(node, vm, name) &#123; Publisher.global = this; this.node = node; this.vm = vm; this.name = name; this.update(); Publisher.global = null;&#125;Watcher.prototype = &#123; constructor: Watcher, update: function ()&#123; let vm = this.vm; let node = this.node; let name = this.name; switch (this.node.nodeType) &#123; case 1: node.value = vm[name]; break; case 3: node.nodeValue = vm[name]; break; default: break; &#125; &#125;&#125;// 实例化VUEvar vm = new Vue(&#123; el: &#x27;container&#x27;, data: &#123; msg: &#x27;Hello world!&#x27;, inpText: &#x27;Input text&#x27;, text: &#x27;测试&#x27; &#125;&#125;) 效果：","categories":[],"tags":[{"name":"vue的双向绑定响应式原理","slug":"vue的双向绑定响应式原理","permalink":"https://liusongfneg.github.io/tags/vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"}]},{"title":"前端面试题整理","slug":"前端面试题整理","date":"2021-04-09T01:52:03.000Z","updated":"2021-04-20T06:51:05.403Z","comments":true,"path":"2021/04/09/前端面试题整理/","link":"","permalink":"https://liusongfneg.github.io/2021/04/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/","excerpt":"1. 什么是BFC元素这篇文章讲的很好什么是BFC元素 2. 对于盒模型的理解盒模型盒模型允许我们在元素周围添加边框，并定义元素之间的空间。 w3c盒模型 从css属性来说，box-sizing: content-box","text":"1. 什么是BFC元素这篇文章讲的很好什么是BFC元素 2. 对于盒模型的理解盒模型盒模型允许我们在元素周围添加边框，并定义元素之间的空间。 w3c盒模型 从css属性来说，box-sizing: content-box 从W3C盒模型来看。盒子的width一般指的是盒子的contentWidth，增加内边距、边框和外边距不会影响content的尺寸，但是会增加元素的总尺寸。box-sizing: content-box 123元素width &#x3D; contentWidth 元素总width &#x3D; contentWidth + padding + border + margin 元素总width &gt;&#x3D; 元素width ie盒模型 从css属性来说，box-sizing: border-box 与W3C盒模型比之，IE盒模型特性完全相反从IE盒模型来看。盒子的width指的就是是盒子的实际宽度，增加内边距、边框和外边距会影响content的尺寸，但是不会增加元素的总尺寸。box-sizing: border-box 123元素width &#x3D; contentWidth + padding + border + margin 元素总width &#x3D; contentWidth + padding + border + margin 元素总width &#x3D; 元素的width w3c盒模型与ie盒模型简单来说就是一个用内容width当作元素width，一个用边框来计算width 3. css3 新特性css3新特性 4. 行内元素和块级元素区别行内元素：与其他行内元素并排不能设置宽高，默认的宽度就是文字的宽度块级元素：霸占一行，不能与其他任何元素并列。能接受宽高，如果不设置宽度，那么宽度将默认变为父级的100%。 5. flex布局特性语法篇实例篇任何一个容器都可以指定为 Flex 布局。行内元素也可以使用 Flex 布局。Webkit 内核的浏览器，必须加上-webkit前缀。注意：设为 Flex 布局以后，子元素的float、clear和vertical-alignd等属性将失效。 6. rem 和em区别rem是根据html根节点来计算的，而em是继承父元素的字体。 7. 怎么让Chrome支持小于12px 的文字？以前可以使用Chrome的CSS私有属性-webkit-text-size-adjust:none; 来取消Chrome的字体限制。但是，在chrome更新到27版本之后就删除了这个属性。-webkit-text-size-adjust:none;只支持英文可以使用CSS3里的transform属性来应对这个问题scale（缩放）表示转换宽高比例大小。使用transform属性有个问题，它也会影响宽高，这样会对布局产生影响，如图效果。这是因为transform:scale()只能对块元素设置，设置后宽高也会比例缩放。 8. 说几种上下左右居中 relative，left top 50%，负margin-left margin-top 123456789101112131415.one&#123; position: relative; width: 100%; height: 500px;&#125;.two&#123; position: absolute; left: 50%; top:50%; margin-left: -100px; margin-top: -100px; background-color: #a00; width: 200px; height: 200px; &#125; absolute，margin: auto 1234567891011.two&#123; position: absolute; margin: auto; left: 0; right: 0; top: 0; bottom: 0; background-color: #a00; width: 200px; height: 200px; &#125; relative，left top 50%，transform: translate(-50%,-50%) 123456789.two&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); background-color: #a00; width: 200px; height: 200px; &#125; flex居中 1234567891011121314 .one&#123; margin:0 auto;width: 100%; height: 500px; display: flex;/*设置外层盒子display为flex*/justify-content:center;/*设置内层盒子的水平居中*/align-items:center;/*设置内层盒子的垂直居中*/ &#125; .two&#123; display: inline-block; background-color: #a00; width: 200px; height: 200px; &#125; 9. 自适应和响应式布局的理解 响应式布局就是不同分辨率视窗，就展示不同的布局。 优点是灵活性强 缺点是废设计 场景 - 网站逻辑不复杂，细节不太在意 自适应就是网页内容的宽度自动去适应视窗宽度 优点是省事，在手机移动端不同的手机上展示效果良好 缺点是不灵活，在pc，手机，或者其他平台必须要写多套代码 场景 - 网站逻辑复杂，重视用户体验静态布局、自适应布局、流式布局、响应式布局、弹性布局等的概念和区别","categories":[],"tags":[{"name":"前端面试题整理","slug":"前端面试题整理","permalink":"https://liusongfneg.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"}]},{"title":"css3新特性","slug":"css3","date":"2021-04-08T09:26:04.000Z","updated":"2021-04-09T01:37:26.995Z","comments":true,"path":"2021/04/08/css3/","link":"","permalink":"https://liusongfneg.github.io/2021/04/08/css3/","excerpt":"过渡transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0) 动画animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running） 形状转换transform：适用于2D或3D转换的元素 rotate(30deg)旋转30° scale(.8)缩放为原来的80% skew(10deg,11deg) 沿横坐标扭曲10°，沿纵坐标扭曲11° rotateX(180deg) 沿着X轴3D旋转180° rotateY(180deg) 沿着y轴3D旋转180° rotate3d(10,10,10,90deg) rotate3d(x,y,z,angle)定义 3D 旋转 选择器","text":"过渡transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0) 动画animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running） 形状转换transform：适用于2D或3D转换的元素 rotate(30deg)旋转30° scale(.8)缩放为原来的80% skew(10deg,11deg) 沿横坐标扭曲10°，沿纵坐标扭曲11° rotateX(180deg) 沿着X轴3D旋转180° rotateY(180deg) 沿着y轴3D旋转180° rotate3d(10,10,10,90deg) rotate3d(x,y,z,angle)定义 3D 旋转 选择器 css3提供的选择器可以让我们的开发，更加方便！这个大家都要了解。下面是css3提供的选择器。 阴影box-shadow: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向（默认是从里往外，设置inset就是从外往里 边框 border-image: 图片url 图像边界向内偏移 图像边界的宽度(默认为边框的宽度) 用于指定在边框外部绘制偏移的量（默认0） 铺满方式–重复（repeat）、拉伸（stretch）或铺满（round）（默认：拉伸（stretch）） 边框圆角border-radius: n1,n2,n3,n4;n1-n4四个值的顺序是：左上角，右上角，右下角，左下角。 背景 background-clip border-box 默认 padding-box 不算border，相当于把border的背景裁掉 content-box 不算border + padding，相当于把border + padding的背景裁掉 background-origin 引用菜鸟教程的说法：background-Origin属性指定background-position属性应该是相对位置 三个值border-box、padding-box、content-box分别是从边框，padding、content的左上角开始 background-size 指定背景的大小 length|percentage|cover|contain 设置背景图像的高度和宽度|以父元素的百分比来设置背景图像的宽度和高度|把背景图像扩展至足够大，以使背景图像完全覆盖背景区域|把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。 反射-webkit-box-reflect:方向[ above-上 | below-下 | right-右 | left-左 ]，偏移量，遮罩图片 文字 换行word-break: normal|break-all|keep-all 默认|半角空格或者连字符处|允许在单词内 word-wrap: normal|break-word; 默认|允许在长单词或url内部换行 text-overflow: ellipsis|clip|string 超出省略号| 超出隐藏 | 使用给定的字符串来代表被修剪的文本。(只在火狐的浏览器上有用) 超出省略号 12345width:200px; border:1px solid #000000;overflow:hidden;white-space:nowrap; text-overflow:ellipsis; 多行超出省略号1234567891011width:400px;margin:0 auto;overflow : hidden;border:1px solid #ccc;text-overflow: ellipsis;padding:0 10px;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical;line-height:30px;height:60px; 文字阴影text-shadow:水平阴影，垂直阴影，模糊的距离，以及阴影的颜色。 颜色 rgba(00,00,00,.5) 一个是rgba（rgb为颜色值，a为透明度） hsla( 112, 72%, 33%, 0.68) h:色相”，“s：饱和度”，“l：亮度”，“a：透明度” 渐变 css3提供了线性渐变、径向渐变、圆锥渐变CSS3 Gradient再说CSS3渐变——线性渐变再说CSS3渐变——径向渐变神奇的 conic-gradient 圆锥渐变（这篇就是看我看到圆锥渐变的文章） Filter（滤镜） 黑白色filter: grayscale(100%) 褐色filter: sepia(1) 饱和度filter: saturate(2) 色相旋转filter: hue-rotate(90deg) 反色filter: invert(1) 透明度filter: opacity(.5) 亮度brightness(.5) 对比度contrast(2) 模糊blur(3px) 阴影drop-shadow(5px 5px 5px #000) 弹性布局 flexFlex 布局教程：语法篇Flex 布局教程：实例篇 Grid布局Grid布局指南 多列布局123456789.newspaper&#123; column-count: 3; -webkit-column-count: 3; -moz-column-count: 3; column-rule:2px solid #000; -webkit-column-rule:2px solid #000; -mox-column-rule:2px solid #000;&#125; 盒模型定义box-sizing:content-box/border-box 媒体查询12345678910@media screen and (max-width: 960px) &#123; body &#123; background-color: darkgoldenrod; &#125;&#125;@media screen and (max-width: 480px) &#123; body &#123; background-color: lightgreen; &#125;&#125; 混合模式–就是允许多个图片/背景合，类似于ps里正片叠底功能css 混合模式","categories":[],"tags":[]},{"title":"同仁堂国际项目总结","slug":"projectSummary","date":"2021-04-02T08:45:31.000Z","updated":"2021-04-02T09:11:19.737Z","comments":true,"path":"2021/04/02/projectSummary/","link":"","permalink":"https://liusongfneg.github.io/2021/04/02/projectSummary/","excerpt":"这算是我的第一篇博客吧，刚好最近刚结束一个项目，有时间动手写点东西。算是结束了吧，长达五个月的的外派，横跨二零与二一年，多多少少有些心得，也发现许多问题需要自审自省。 去年十一月分吧，刚从广州出差回来的我有点懵逼，立马又被外派另一个公司开发项目去了，老实说我屁股都没坐热呢，吐槽完毕开始正式内容 项目名称：同仁堂国际致力于成为全球化领先的智慧健康服务平台,我们以“人”为中心,借助大数据、人工智能、区块链及5G等技术互联医疗健康服务场景与用户数据体系,为人们提供从健康咨询与管理、在线诊疗...等服务 而我则是负责其中web前端开发人员之一，项目采用前后端分离的主流方案，前端也分为四个端，wx小程序端，H5端，安卓端与ios端，其中wx小程序与H5则由我与另外一名wen前端开发人员开发。同时我们还负责开发后端管理系统，后端管理系统应用的是微服务，同时管理医疗服务，商城，等等系统 先谈谈此次项目经历的收获吧先从基础的东西说起吧，代码规范检查–eslint ：插件化的 javascript 代码检测工具eslint的最直观的优势就在于美观，统一团推代码风格。而且eslint也能检查语法，规避隐藏的语法错误项目反思","text":"这算是我的第一篇博客吧，刚好最近刚结束一个项目，有时间动手写点东西。算是结束了吧，长达五个月的的外派，横跨二零与二一年，多多少少有些心得，也发现许多问题需要自审自省。 去年十一月分吧，刚从广州出差回来的我有点懵逼，立马又被外派另一个公司开发项目去了，老实说我屁股都没坐热呢，吐槽完毕开始正式内容 项目名称：同仁堂国际致力于成为全球化领先的智慧健康服务平台,我们以“人”为中心,借助大数据、人工智能、区块链及5G等技术互联医疗健康服务场景与用户数据体系,为人们提供从健康咨询与管理、在线诊疗...等服务 而我则是负责其中web前端开发人员之一，项目采用前后端分离的主流方案，前端也分为四个端，wx小程序端，H5端，安卓端与ios端，其中wx小程序与H5则由我与另外一名wen前端开发人员开发。同时我们还负责开发后端管理系统，后端管理系统应用的是微服务，同时管理医疗服务，商城，等等系统 先谈谈此次项目经历的收获吧先从基础的东西说起吧，代码规范检查–eslint ：插件化的 javascript 代码检测工具eslint的最直观的优势就在于美观，统一团推代码风格。而且eslint也能检查语法，规避隐藏的语法错误项目反思 经过五个月的开发，同仁堂国际项目终于告一段落了，这个项目对我来说，挑战性很强，这里重点讲一下在这个项目中我暴露出来的问题缺乏沟通可能由于性格原因，与领导和不熟悉的同事沟通的少。导致一些需求或者问题理解的不是很全面，从而影响开发质量和速度关于沟通问题，就要提到我的同事姜南，他有问题就直说，不解的地方直接拿着电脑去找产品。关于沟通这一点我要多多向姜南学习临阵磨枪有时候，项目中会遇到一些新的技术或者一些特殊的需求。对于这种没有经验的新技术或者特殊需求，确实很需要提前准备策略应对，新技术就抽时间快速学习，特殊需求就抽时间与别人交流或者独自出解决方案，而不是临阵磨枪，走一步看一步，效率低不说，代码崩溃的风险还高开发效率本人的开发速度确实有点慢，开发后的页面或者功能总会有些小问题，结合下来，我的开发效率确实有点低了开发效率是一个综合性的问题，想提升也不是一朝一夕的事情，既然发现的了这个问题，那就只能着手解决这个问题了第一点是沟通问题：在接到任务的第一时间必须把需求和目标明确，有了明确的目标，才能准确的朝着目标快速前进，少走弯路第二点是代码规范化：标准化的代码编写，不管是对个人，还是对与团队来说，都是非常重要的。良好的编码习惯就像黑夜里的一盏明灯，指引迷路的开发者靠岸。标准化的，规范会的代码能大大的提高代码的可读性，可扩展性和整体质量，从而提升代码编写的效率前端编程中就有一款非常方便的JavaScript代码检测工具，可以用来自定义代码格式与检查代码语法，避免低级代码","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-03-24T02:49:33.207Z","updated":"2021-04-20T06:53:30.982Z","comments":true,"path":"2021/03/24/hello-world/","link":"","permalink":"https://liusongfneg.github.io/2021/03/24/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 搭建免费个人博客教程More info: blog","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"vue的双向绑定响应式原理","slug":"vue的双向绑定响应式原理","permalink":"https://liusongfneg.github.io/tags/vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"},{"name":"前端面试题整理","slug":"前端面试题整理","permalink":"https://liusongfneg.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"}]}